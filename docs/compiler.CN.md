# Xue语言编译器设计文档

本文档主要讲述了Xue语言编译器的每一个设计细节以及各字节码的实现原理，

## 助记符分类

在Xue语言中，并非所有的助记符都是指令，助记符分为运行时助记符和编译时助记符。其中运行时助记符在程序编译过程中会被输出为对应的指令操作码，而编译时助记符有时不会生成指令，只是给编译器提供信息。

### 典型的运行时助记符

例如，`ADD`，`SUB`助记符对应了指令操作码中的`ADD`和`SUB`。编译器在编译时将会把这些助记符输出成对应的指令格式，同时如果需要额外的数据信息，也会通过添加`PUSH`等指令来完成。

### 编译时助记符一览

目前为止，只有助记符`VAR`是编译时助记符。编译器内部维护了一个编译上下文，其存储了一张局部变量符号表，用于存储局部变量的编号和相关信息，每当用户使用一次`VAR`助记符，编译器就会判断是否声明过该局部变量，若有则抛出语义错误。否则将其加入到符号表中。在代码生成阶段，编译器会根据收集到的所有局部变量信息，按顺序压入栈，并记录其栈上偏移值。

## 变量引用

Xue语言中，如果要引用变量，分两种情况，引用局部变量和引用全部变量。局部变量直接输入标识符，编译器在语义分析过程中会检查该变量是否定义在符号表中，若没有则抛出语义错误。而全局变量则需要添加一个`$`符号用作区分，此时编译器会检查全局变量符号表，处理过程与局部变量的类似，不再介绍。

在代码生成阶段，对于引用局部变量的代码，编译器会将其转化为栈上的偏移值。而对于全局变量，则会转换成全局变量索引值，具体的读取过程交由虚拟机进行。

## 伪指令解析

目前为止，Xue语言共支持三种伪指令，分别是`label`、`global`、`import`。

用户可以在任何地方使用这三个伪指令，但如果要引用其中的变量或者标签，必须在引用之前使用伪指令，否则会因为编译器无法从符号表中查找到标识符而停止编译。

首先介绍`global`伪指令的机制，在编译器发现`label`伪指令之前都会默认在声明全局变量。因此调用伪指令之后可以使用的只有`VAR`助记符，如果发现其他助记符，则会抛出语义错误。

接下来介绍`label`伪指令，Xue语言要求不存在空标签，所以使用伪指令后必须至少跟随一行助记符，否则将会抛出语义错误。编译器会采用一张标签符号表自顶向下逐个标记每个标签的指令偏移量，所以对于`JMP`类型的指令，其源码形式下填写的标签名称在字节码生成阶段会转换成对应的标签偏移量。

对于`import`和`export`伪指令。`import`伪指令要求至少有一个字符串在该伪指令之后出现，字符串的声明形式与普通字符串相同，只不过不会加入常量池中。该字符串的内容是需要导入的文件的路径，路径与路径之间使用一个逗号隔开。被导入的文件源码会被加载进该文件，最后统一编译。目前还未支持字节码合并功能，未来可能会实装。




