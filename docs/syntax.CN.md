# Xue语言语法

[English](./syntax.md) | **简体中文**

注意：Xue语言遵从GNU AT&T汇编格式。

## 基本数据类型

不管是物理机还是虚拟机，都有最小的原子单位，通常情况下这个基本单位是字节，一个字节由8个比特位组成。在Xue语言虚拟机中，其基本单位也是字节。而像字符串，浮点数之类的基本数据类型也是由字节组成的。基本数据类型和基本单位之间的区别就是，基本数据类型有数据结构，而字节是没有结构的。以下是关于如何声明基本数据类型的代码示例。

```nasm
  VAR myint, 12      ; 声明一个名叫myint的整数变量，并将整数值12赋给该变量。
                     ; 之后变量将会被压入栈顶，同时该变量的偏移值将会被记入
                     ; 哈希表中。

  VAR myfloat, 3.0   ; 声明一个名叫myfloat的浮点数变量，并将实数3.0赋给该
                     ; 变量。之后将变量压入栈顶，并记录偏移值。

  VAR mychar, 'A'    ; 声明一个字符变量mychar，字符变量在Xue中是一个大小为1
                     ; 字节的无符号整型变量。目前为止，Xue语言的字符仅支持
                     ; ASCII码字符，不支持UTF8编码等。在本例中，mychar的值
                     ; 应该为97.

  VAR mystring, @"Hello"    ; 声明一个字符串变量mystring，"Hello"字符串将会
                            ; 被存储在常量池中。因此，实际上mystring存储的是
                            ; 一个常量字符串索引，也就是在虚拟机栈上的是一个
                            ; 32位无符号整数。
```

需要注意，字符类型被两个单引号`'`所包裹，而字符串类型以`@`符号开头，被双引号`"`包围。

如果你想要在助记符中引用变量，对于不同作用域的变量，需要用不同的方式进行引用：

1. 如果引用的是局部变量，则直接输入变量的标识符即可，编译器在编译时会将这些标识符转换成栈上的偏移值。

2. 如果引用的是全局变量，你需要在变量名之前加一个`$`符号，用以和局部变量进行区分。然后写入全局变量的标识符即可。全局变量是被存储在全局数据区中的，因此编译器会将引用全局变量的位置转换成一个全局变量索引值。

3. 如果你需要调用一个外部函数，也需要加上`$`符号。

## 助记符和伪指令

### 变量声明与引用

你可以使用`VAR`指令来声明一个变量，声明变量的格式为`VAR NAME, VALUE`。其中，`NAME`表示变量的标识符，标识符的正则表达式如下`[a-zA-Z_][0-9a-zA-Z_]*`。只有满足该正则式的字符串才能成为标识符，否则编译器将会抛出编译异常。而`VALUE`表示赋给变量的值，可以是字面量，也可以是引用其他变量的值。

下面来介绍局部变量和全局变量。

在Xue语言中，凡是存放在虚拟机栈上的变量都叫做局部变量，局部变量的作用域为一整个栈。而存储在全局数据区的变量则叫做全局变量。如果要引用局部变量的值，则直接写入局部变量标识符名称即可，而如果要引用全局变量的标识符名称，则还需要在标识符前加上一个`$`符号。

如果要声明全局变量，你需要使用伪指令`global`，伪指令以一个`.`符号开始，随后是伪指令的名称，然后是一个`:`。需要注意的是，如果要结束全局变量声明，你需要在声明指令之后跟上一个标签。

关于声明和引用变量的代码示例如下。

```nasm
  VAR refVar, $globalVar          ; 声明一个局部变量refVar，其引用了全局变量
                                  ; globalVar的值。

  .global:
    VAR globalVar 0.2             ; 声明一个全局变量globalVar并赋值0.2.
    VAR globalStr @"Hello World!" ; 声明一个全局字符串变量globalStr，并将
                                  ; 常量字符串赋给该变量。

  .label main:                    ; 全局变量声明结束。
    ...
```

### 出栈和入栈

因为Xue语言的虚拟机是一个堆栈虚拟机，所以必然提供了`PUSH`和`POP`指令。你可以将字面量或者变量的值入栈，也可以将当前栈指针指向的位置出栈。

`PUSH`指令的助记符格式为`PUSH VALUE`，其中`VALUE`可以是字面量也可以是引用变量的名称。

`POP`指令的助记符格式为`POP VAR`，其中`VAR`表示局部变量或全局变量，从栈顶被弹出的值需要存储在任何一种变量中。

关于入栈和出栈的代码示例如下。

```nasm
  PUSH  1                        ; 将字面量1压入栈。
  PUSH  locVar                   ; 将局部变量locVar的值压入栈顶。
  PUSH $globVar                  ; 将全局变量globVar的值压入栈顶

  VAR LOCINTVAR 0                ; 声明一个局部变量LOCINTVAR，赋初值0
  POP LOCINTVAR                  ; 弹出栈顶的值，赋给局部变量LOCINTVAR
  POP $globVar                   ; 弹出栈顶的值，赋给全局变量globVar
```

### 算术运算

当然，Xue语言也提供了最基本的算术运算能力，包括加减乘除和模运算。

`ADD`指令表示加法运算，格式为`ADD VAR`，`VAR`表示局部变量或全局变量。该指令将会从栈顶弹出两个值，然后相加，将结果存入`VAR`中。

`SUB`指令表示减法运算，格式和`ADD`指令相同。需要注意，先被弹出的值作为被减数，后被弹出的值作为减数。

`MUL`指令表示乘法运算，因为和`ADD`指令相似就不再说明。

`DIV`指令表示除法运算，被弹出的第一个值作为被除数，第二个值作为除数。

`MOD`指令表示模运算，被弹出的第一个值表示模数，第二个值表示被模数。

### 控制流

Xue语言也包含了跳转指令和比较指令，你可以使用无条件跳转和有条件跳转来实现高级语言中的`if`，`if-else`语句。

`label`标签伪指令，用于标记一个标签的指令起始位置。标签名称需要满足标识符匹配规则，且标签是文件作用域，即同一个文件不能存在同名的标签。

`JMP`指令表示无条件跳转，其格式为`JMP LABEL`，其中`LABEL`表示将要跳转的标签名称，需要填入一个已经声明的标签名，否则会抛出编译错误。

`CMP`指令表示进行数值比较，格式为`CMP [VAR]`。需要弹出两个整型或者浮点型数据，这里的`VAR`参数为可选，如果不填则比较结果将会被压入栈顶。否则将会把值赋给指定的变量。

`JGE`为有条件跳转指令，其格式为`JGE LABEL`。指令弹出一个比较结果，如果弹出的值大于等于0，则跳转到指定标签处，否则不跳转，执行该指令后的下一行。

`JLE`也为有条件跳转指令，其格式为`JLE LABEL`。如果弹出的值小于等于0则跳转。

`JGT`格式同上。如果弹出的值大于0，则跳转。

`JLT`格式同上。如果弹出的值小于0，则跳转。

`JEQ`格式同上。如果弹出的值等于0，则跳转。

`JNE`格式同上。如果弹出的值不等于0，则跳转。

### 函数调用

除此之外，Xue语言还提供了调用C-ABI兼容函数的能力。通过`CCALL`指令即可调用，格式如下：`CCALL FUNCTION`，其中`FUNCTION`参数表示外部函数名称，需在名称前加上`$`符号。

例如，使用`printf`函数输出`Hello World!`的例子如下。

```nasm
  PUSH @"Hello World!"
  CCALL $printf
```

### 特性

Xue语言还提供了2个指令，`CPY`和`EXIT`。其中`CPY`指令将会弹出一个值，然后重复压入该值两次。而`EXIT`指令则会在执行后立刻退出程序。

为了避免重复编写程序，Xue语言提供了`import`和`export`伪指令。

如果要导入标准库`std.xue`，代码示例如下。

```nasm
.import:
  @"std/std.xue"
```



### 注释

在Xue语言中，仅提供行级注释，以`;`开始，随后可以是任何文本。例如：

```nasm
        ; 这是注释
```

### 语言示例

为了帮助更好地学习该语言，接下来给出两个简单的代码示例。

#### Xue语言版Hello World

```nasm
  PUSH @"Hello World in Xue!"
  CCALL $printf
```

#### Xue语言版斐波那契数列

```nasm
.global:
  VAR f1 0
  VAR f2 1
  VAR count 2
label fibonacci_init:
  PUSH @"We will output the first 20 items of Fibonacci.\n1:1\n"
  CCALL $printf
  JMP fibonacci_check
label fibonacci_check:
  PUSH $count
  PUSH 21
  CMP
  JLT fibonacci_body
  PUSH @"Here is the end of the Fibonacci example!"
  CCALL $printf  
label fibonacci_body:
  VAR f3 0
  PUSH $f1
  PUSH $f2
  ADD f3
  PUSH $f2
  PUSH 0
  ADD  $f1
  PUSH $f3
  PUSH 0
  ADD  $f2  
  PUSH @"%d:%d\n"
  PUSH $count
  PUSH f3
  CCALL $printf
  PUSH $count
  PUSH 1
  ADD $count
  JMP fibonacci_check
```
